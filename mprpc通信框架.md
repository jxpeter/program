# mprpc通信框架





* 集群：每台服务器独立运行一个工程的所有模块
* 分布式：一个工程拆分为很多模块，每个模块独立部署运行在一个服务器上，所有服务器协同工作共同提高服务，每台服务器称作分布式的一个节点。



**RPC通信原理**

* RPC（远程过程调用协议）

![image-20240518010759924](../../../AppData/Roaming/Typora/typora-user-images/image-20240518010759924.png)

​	黄色部分：设计rpc方法参数的打包和解析，也就是数据的序列化和反序列化，使用``Protobuf`。

​	绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用``muduo`网络
库和`zookeeper`服务配置中心（专门做服务发现）。



## protobuf简介

### 语法

~~~protobuf
syntax = "proto3"      //指定版本信息
//proto3语法
package pb；    //后期生产go文件的包名

//字段类型
message SearchRequest{
string query= 1;
...
reperted string snippets =4;  //repeated 字段规则  在格式正确的消息中，此字段类型可以重复零次 或多次。系统会保留重复值的顺序
reserved “foo”；     //reserved 保留字段  为了避免再次使用到已移除的字段可以设定保留字段。如果任何未来用户尝试使用这些字段标识符，编译器就会报错
}
~~~





### 编译

**protobuf 编译是通过编译器 protoc 进行的，通过这个编译器，我们可以把 .proto 文件生成 go,Java,Python,C++, Ruby或者C# 代码**

~~~C++
protoc --cpp_out= . preson.proto
~~~

protobuf 编译器会把 .proto 文件编译成 .pd.c++ 文件





## linux GDB调试

* 启动GDB

~~~c
gdb program core
//用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。

~~~

常用的调试指令

* 在进入函数func时，设置一个断点
  * `(breake)b func`

* 在GDB中运行程序

  * 当以 gdb 方式启动gdb后，gdb会在PATH路径和当前目录中搜索源文件，运行程序使用r或是run命令

* 程序运行参数

  * `set args` 指定运行时参数

* 运行环境

  * `show paths`查看程序运行路径
  * `show env[avrname]` 查看环境变量

* ~~~C
  quit/q   //退出gdb;
  list/l+([文件名：])+[行号/函数名]   //展示（文件）某行/某函数的代码;
  b+（文件名）+[行号/函数名]   //打断点
  info/i  + b   //查看断点信息
  d + [断点编号]   // 删除断点
  enable/disable + [断点编号]  //打开或关闭某个断点
  next/n  //逐过程运行
  step/s   //逐语句运行
  p + [变量]   //查看变量信息
  display  +  [变量]  //常显示变量信息
  c    //（continue）运行至下一个断点
  finish  // 运行结束当前函数
  until +[line number]   //运行至指点行数
      
      
  ~~~





## kafka简介 （未完）

本质上是一个消息队列

* 概念： Broker  ： 一台Kafka机器就是一个Broker ，一个集群有多个Broker组成，一个Broker可以容乃对各Topic
* Topic： 可以理解为一个队列，生产者消费之面向同一个Topic



## zookeeper

**zk中创建的节点分为两种：**

​	**永久性节点和临时性节点。永久性节点即创建以后，在不执行delete命令的前提下，该节点是永久存在的；而临时节点与session有关，每个客户端与zk建立链接的时候会生成一个session，这个session不会因为链接zk服务器节点的变化而变化，只有当客户端断开连接以后，该session才会消失，而临时节点会随着session的消失而消失**

​	**zk拥有watch机制，也就是监视机制，可以支持响应式编程模式，它可以对某个路径的终节点及其子节点的变更进行监视，当其发生变更以后，会调用注册的callback方法，然后进行具体的业务逻辑。例如监测路径为/A/A1，那么它会加测A1节点，以及附属于A1的所有子节点，这个子不单单只一层子节点，是指所有层的子节点。**



​	zk的集群是主从集群，客户端可以随意与任何zk服务节点进行连接，并且各个客户端都可以进行读写操作，这是一个和redis主从集群的区别，redis的主从集群，如果客户端是写操作，那么只能连接redis的主节点才可以。zk的每个客户端是随机连接到zk服务节点的，并且每个客户端都可以进行读写操作，读操作都是在客户端连接的zk节点进行操作；而写操作是有区别的，如果该客户端连接的是leader节点，那么直接进行写操作；如果该客户端连接的是follower节点，那么zk的服务节点会自动将该写操作转到leader节点进行。







##  小知识点总结

在C++中与时间相关的函数参数通常涉及`<ctime>`头文件中的函数和结构体

* `time_t` 表示从某个固定时间（1970.1.1）经过的秒数的整数类型
*  `struct tm`  结构体，用于保存日期和时间信息
* `time()`  函数，获取当前时间，返回`time_t`类型
* `localtime()` 函数，将`time_t`类型时间转换为本地时间，并指向`struct tm`  结构体的指针





**std::string类相关的函数**

* `append()或 +=`  用于将一个字符串追加到另一个末尾
* `insert()`  用于在字符串指定位置插入另一个字符串
* `erase()`  用于删除字符串中指定部分
* `c_str()`  用于返回一个指向以空字符结尾的C风格的字符串指针



 

**sem_t 信号量类型**

* sem_t类型通过`<semaphore.h>` 头文件进行声明
* `sem_init()`  初始化一个信号量，设置信号量初值，**他接受三个参数，指向`sem_t`类型的指针，2，信号量的共享性，信号量的初始值**
* `sem_wait()` 用于对信号量等待操作
* `sem_post()`

* `sem_destory()`用于销毁信号量







**C++byte**

C++17 引入`std::byte`  是一个固定大小的字节类型，用于表示原始字节

`std::byte bytes[4]={}`



**EXIT_FAILURE**

这是个预定义的宏，用于表示程序因为某种错误而退出时的退出码。通常定义在`<cstdlib>`

在Unix系统中，通常被定义为1





 **recv函数**

套接字编程中用于接收数据的函数，通常在TCP或UDP套接字上使用

~~~C
#include<sys/socket.h>

ssize_t recv(int sockfd, void*buf , size_t len,int flags);
~~~





**http 的session **

就是一个在服务器上用来存储用户信息的机制，它通过``session Id `来标识用户，并在用户发送请求时提供相应服务



**静态动态转换**

1. 静态转换是在编译时确定的，而动态转换是在运行时确定的。静态转换是通过类型转换操作符（如static_cast）来进行的，编译器在编译时会进行类型检查，如果类型不匹配则会报错；而动态转换是通过类型转换操作符（如dynamic_cast）来进行的，在运行时会进行类型检查，如果类型不匹配则返回空指针或引发异常。
2. 静态转换可以用于任意类型之间的转换，包括基类指针/引用向派生类指针/引用的转换，以及相互之间的转换；而动态转换只能用于含有虚函数的类之间的转换，主要用于在运行时确定对象的实际类型。
3. 静态转换不会进行运行时类型检查，因此可能会导致类型不安全的问题；而动态转换会进行运行时类型检查，确保类型转换的安全性。

**静态转换适用于已知类型之间的转换，效率高但不安全；动态转换适用于未知类型之间的转换，安全但效率相对较低。**



